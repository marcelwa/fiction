//
// Created by gregor on 12/30/18.
//

#ifndef FICTION_WRITE_SVG_LAYOUT_HPP
#define FICTION_WRITE_SVG_LAYOUT_HPP

#include "../layouts/coordinate.hpp"
#include "utils/version_info.hpp"

#include <fmt/format.h>

#include <array>
#include <cmath>
#include <iostream>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

namespace fiction
{

struct write_qca_layout_svg_params
{
    bool simple = false;
};

class unsupported_cell_type_exception : public std::exception
{
  public:
    explicit unsupported_cell_type_exception(const coord_t& c) noexcept : std::exception(), coord{c} {}

    [[nodiscard]] coord_t where() const noexcept
    {
        return coord;
    }

  private:
    const coord_t coord;
};

namespace detail
{

namespace svg
{

// General layout
static constexpr const double viewbox_distance = 11;
static constexpr const double tile_distance    = 119;
static constexpr const double cell_distance    = 23;

// Generic tiles
static constexpr const int    starting_offset_tile_x = -175;
static constexpr const int    starting_offset_tile_y = -58;
static constexpr const double starting_offset_cell_x = 3.5;
static constexpr const double starting_offset_cell_y = -40.25;

// Latch tiles
static constexpr const double starting_offset_latch_x      = -483.5;
static constexpr const int    starting_offset_latch_y      = -57;
static constexpr const int    starting_offset_latch_cell_x = 312;
static constexpr const int    starting_offset_latch_cell_y = -41;

// Colors
static constexpr const char* clock_zone_1_cell     = "86e291";
static constexpr const char* clock_zone_2_cell     = "ffa5fa";
static constexpr const char* clock_zone_3_cell     = "00c8bc";
static constexpr const char* clock_zone_4_cell     = "ffffff";
static constexpr const char* clock_zone_latch_cell = "ffe33a";
static constexpr const char* clock_zone_1_tile     = "ffffff";
static constexpr const char* clock_zone_2_tile     = "bfbfbf";
static constexpr const char* clock_zone_3_tile     = "7f7f7f";
static constexpr const char* clock_zone_4_tile     = "3f3f3f";
static constexpr const char* clock_zone_12_text    = "000000";
static constexpr const char* clock_zone_34_text    = "ffffff";
static constexpr const char* pi_cell               = "008dc8";
static constexpr const char* po_cell               = "e28686";

// SVG parts with placeholders
static constexpr const char* header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n"
                                      "<!-- Generated by {} ({}) -->\n"
                                      "\n"
                                      "<svg\n"
                                      "xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n"
                                      "xmlns:cc=\"http://creativecommons.org/ns#\"\n"
                                      "xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n"
                                      "xmlns:svg=\"http://www.w3.org/2000/svg\"\n"
                                      "xmlns=\"http://www.w3.org/2000/svg\"\n"
                                      "viewBox=\"0 0 {} {}\"\n"
                                      "version=\"1.1\">\n"
                                      "<metadata>\n"
                                      "<rdf:RDF>\n"
                                      "<cc:Work\n"
                                      "rdf:about=\"\">\n"
                                      "<dc:format>image/svg+xml</dc:format>\n"
                                      "<dc:type\n"
                                      "rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n"
                                      "<dc:title></dc:title>\n"
                                      "</cc:Work>\n"
                                      "</rdf:RDF>\n"
                                      "</metadata>\n"
                                      "<g>\n"
                                      "{}\n"
                                      "</g>\n"
                                      "</svg>";

static constexpr const char* tile =
    "<g\n"
    "transform=\"translate({0},{1})\">\n"
    "<g>\n"
    "<rect\n"
    "ry=\"1.4357216\"\n"
    "y=\"69.390663\"\n"
    "x=\"186.11467\"\n"
    "height=\"118.80357\"\n"
    "width=\"118.80357\"\n"
    "style=\"fill:#{2};stroke:#000000;\" />\n"
    "<text\n"
    "y=\"179.25412\"\n"
    "x=\"288.74234\"\n"
    "style=\"font-style:normal;font-weight:normal;font-size:14.5px;line-height:125%;font-"
    "family:'Noto Sans';fill:#{4};stroke:none;\"\n"
    "xml:space=\"preserve\"><tspan\n"
    "y=\"179.25412\"\n"
    "x=\"288.74234\">{5}</tspan></text>\n"
    "</g>\n"
    "<g>\n"
    "{3}\n"
    "</g>\n"
    "</g>";

static constexpr const char* latch =
    "<g\n"
    "transform=\"translate({0},{1})\">\n"
    "<g>\n"
    "<g>\n"
    "<g>\n"
    "<path\n"
    "d=\"m 613.38686,68.413109 0,118.803571 -118.80358,0\"\n"
    "style=\"color:#000000;solid-color:#000000;solid-opacity:1;fill:#{2};fill-opacity:1;fill-rule:nonzero;stroke:none;"
    "stroke-width:1.19643486;stroke-opacity:1;enable-background:accumulate\" />\n"
    "<path\n"
    "d=\"m 494.58328,187.21668 0,-118.80357 118.80358,0\"\n"
    "style=\"color:#000000;solid-color:#000000;solid-opacity:1;fill:#{3};fill-opacity:1;fill-rule:nonzero;stroke:none;"
    "stroke-width:1.19643486;stroke-opacity:1;enable-background:accumulate\" />\n"
    "</g>\n"
    "<rect\n"
    "style=\"color:#000000;solid-color:#000000;solid-opacity:1;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#"
    "000000;stroke-width:1.19643486;stroke-opacity:1;enable-background:accumulate\"\n"
    "width=\"118.80357\"\n"
    "height=\"118.80357\"\n"
    "x=\"494.58328\"\n"
    "y=\"68.413109\"\n"
    "ry=\"1.4357216\" />\n"
    "</g>\n"
    "<text\n"
    "y=\"86.340652\"\n"
    "x=\"504.43588\"\n"
    "style=\"font-style:normal;font-weight:normal;font-size:12.5px;line-height:125%;font-family:'Noto "
    "Sans';letter-spacing:0px;word-spacing:0px;fill:#{5};fill-opacity:1;\"\n"
    "xml:space=\"preserve\"><tspan\n"
    "y=\"86.340652\"\n"
    "x=\"504.43588\">{6}</tspan></text>\n"
    "<text\n"
    "y=\"178.27962\"\n"
    "x=\"596.48468\"\n"
    "style=\"font-style:normal;font-weight:normal;font-size:12.5px;line-height:125%;font-family:'Noto "
    "Sans';letter-spacing:0px;word-spacing:0px;fill:#{7};fill-opacity:1;\"\n"
    "xml:space=\"preserve\"><tspan\n"
    "y=\"178.27962\"\n"
    "x=\"596.48468\">{8}</tspan></text>\n"
    "</g>\n"
    "<g>\n"
    "{4}\n"
    "</g>\n"
    "</g>";

static constexpr const char* cell = "<g\n"
                                    "style=\"fill:#{0};\"\n"
                                    "transform=\"translate({1},{2})\">\n"
                                    "<rect\n"
                                    "style=\"fill:#{0};stroke:#000000;\"\n"
                                    "width=\"20\"\n"
                                    "height=\"20\"\n"
                                    "x=\"185.86807\"\n"
                                    "y=\"112.92032\"\n"
                                    "ry=\"1.5\" />\n"
                                    "<g\n"
                                    "style=\"fill:#{0};\"\n"
                                    "transform=\"translate(-0.22642517,-0.09405518)\">\n"
                                    "<circle\n"
                                    "r=\"2.7314816\"\n"
                                    "cx=\"191.0945\"\n"
                                    "cy=\"118.01437\"\n"
                                    "style=\"opacity:1;fill:#{0};stroke:#000000;\" />\n"
                                    "<circle\n"
                                    "r=\"2.7314816\"\n"
                                    "cx=\"191.0945\"\n"
                                    "cy=\"128.01437\"\n"
                                    "style=\"opacity:1;fill:#{0};stroke:#000000;\" />\n"
                                    "<circle\n"
                                    "r=\"2.7314816\"\n"
                                    "cx=\"201.0945\"\n"
                                    "cy=\"128.01437\"\n"
                                    "style=\"opacity:1;fill:#{0};stroke:#000000;\" />\n"
                                    "<circle\n"
                                    "r=\"2.7314816\"\n"
                                    "cx=\"201.0945\"\n"
                                    "cy=\"118.01437\"\n"
                                    "style=\"opacity:1;fill:#{0};stroke:#000000;\" />\n"
                                    "</g>\n"
                                    "</g>";

static constexpr const char* const0 = "<g\n"
                                      "style=\"fill:#000000;fill-opacity:1\"\n"
                                      "transform=\"translate({1},{2})\">\n"
                                      "<rect\n"
                                      "style=\"fill:#000000;stroke:#000000;\"\n"
                                      "width=\"20\"\n"
                                      "height=\"20\"\n"
                                      "x=\"185.86807\"\n"
                                      "y=\"112.92032\"\n"
                                      "ry=\"1.5\" />\n"
                                      "<g\n"
                                      "style=\"fill:#000000;fill-opacity:1\"\n"
                                      "transform=\"translate(-0.22642517,-0.09405518)\">\n"
                                      "<circle\n"
                                      "r=\"2.7314816\"\n"
                                      "cx=\"191.0945\"\n"
                                      "cy=\"118.01437\"\n"
                                      "style=\"fill:#ffffff;stroke:#ffffff;\" />\n"
                                      "<circle\n"
                                      "r=\"2.7314816\"\n"
                                      "cx=\"201.0945\"\n"
                                      "cy=\"128.01437\"\n"
                                      "style=\"fill:#ffffff;stroke:#ffffff;\" />\n"
                                      "</g>\n"
                                      "</g>";

static constexpr const char* const1 = "<g\n"
                                      "style=\"fill:#000000;\"\n"
                                      "transform=\"translate({1},{2})\">\n"
                                      "<rect\n"
                                      "style=\"fill:#000000;stroke:#000000;\"\n"
                                      "width=\"20\"\n"
                                      "height=\"20\"\n"
                                      "x=\"185.86807\"\n"
                                      "y=\"112.92032\"\n"
                                      "ry=\"1.5\" />\n"
                                      "<g\n"
                                      "style=\"fill:#000000;\"\n"
                                      "transform=\"translate(-0.22642517,-0.09405518)\">\n"
                                      "<circle\n"
                                      "r=\"2.7314816\"\n"
                                      "cx=\"191.0945\"\n"
                                      "cy=\"128.01437\"\n"
                                      "style=\"fill:#ffffff;stroke:#ffffff;\" />\n"
                                      "<circle\n"
                                      "r=\"2.7314816\"\n"
                                      "cx=\"201.0945\"\n"
                                      "cy=\"118.01437\"\n"
                                      "style=\"fill:#ffffff;stroke:#ffffff;\" />\n"
                                      "</g>\n"
                                      "</g>";

static constexpr const char* via = "<g\n"
                                   "style=\"fill:#{0};\"\n"
                                   "transform=\"translate({1},{2})\">\n"
                                   "<g>\n"
                                   "<rect\n"
                                   "transform=\"rotate(90)\"\n"
                                   "ry=\"1.5\"\n"
                                   "y=\"-205.86807\"\n"
                                   "x=\"112.92032\"\n"
                                   "height=\"20\"\n"
                                   "width=\"20\"\n"
                                   "style=\"fill:#{0};stroke:#000000;\" />\n"
                                   "<circle\n"
                                   "r=\"7.446404\"\n"
                                   "transform=\"rotate(90)\"\n"
                                   "cx=\"122.92032\"\n"
                                   "cy=\"-195.86807\"\n"
                                   "style=\"fill:none;stroke:#000000;\" />\n"
                                   "</g>\n"
                                   "</g>";

static constexpr const char* cross =
    "<g\n"
    "style=\"fill:#{0};fill-opacity:1\"\n"
    "transform=\"translate({1},{2})\">\n"
    "<g>\n"
    "<rect\n"
    "transform=\"rotate(90)\"\n"
    "ry=\"1.5\"\n"
    "y=\"-205.86807\"\n"
    "x=\"112.92032\"\n"
    "height=\"20\"\n"
    "width=\"20\"\n"
    "style=\"fill:#{0};stroke:#000000;\" />\n"
    "<g\n"
    "style=\"stroke-width:1.05832684;stroke-miterlimit:4;stroke-dasharray:none\"\n"
    "transform=\"matrix(0.94695856,0,0,0.94341063,31.332271,8.4394994)\">\n"
    "<path\n"
    "style=\"stroke:#000000;\"\n"
    "d=\"m 165.8261,113.42213 c 15.83125,15.8311 15.8515,15.85136 15.8515,15.85136\"/>\n"
    "<path\n"
    "style=\"stroke:#000000;\"\n"
    "d=\"m 181.6776,113.42213 c -15.83124,15.83111 -15.85149,15.85137 -15.85149,15.85137\"/>\n"
    "</g>\n"
    "</g>\n"
    "</g>";

static constexpr const char* simple_cell = "<g\n"
                                           "transform=\"translate({1},{2})\">\n"
                                           "<rect\n"
                                           "ry=\"1.5\"\n"
                                           "y=\"112.92032\"\n"
                                           "x=\"185.86807\"\n"
                                           "height=\"20\"\n"
                                           "width=\"20\"\n"
                                           "style=\"fill:#{0};stroke:#000000;\" />\n"
                                           "</g>";

}  // namespace svg

template <typename Lyt>
class write_qca_layout_svg_impl
{
  public:
    write_qca_layout_svg_impl(const Lyt& layout, std::ostream& stream, write_qca_layout_svg_params p) :
            lyt{layout},
            os{stream},
            ps{p}
    {}

    void run()
    {
        if (lyt.get_tile_size_x() == 1 && lyt.get_tile_size_y() == 1)
        {
            generate_cell_based_svg();
        }
        else
        {
            generate_tile_based_svg();
        }
    }

  private:
    Lyt lyt;

    std::ostream& os;

    write_qca_layout_svg_params ps;

    /**
     * Alias for an SVG description of a tile containing also its clock zone.
     */
    using tile_description = std::pair<std::string, typename Lyt::clock_number_t>;
    /**
     * Maps coordinates of tiles to their string representation and their clock zone.
     */
    using coord_to_tile_mapping = std::unordered_map<coord_t, tile_description>;
    /**
     * Maps coordinates of tiles to a string representation of the cells contained within them.
     */
    using coord_to_cell_list_mapping = std::unordered_map<coord_t, std::string>;
    /**
     * Alias for an SVG description of a latch tile containing also its clock zone and its offset.
     */
    //    using svg_latch = std::tuple<std::string, typename Lyt::clock_zone_t, typename Lyt::latch_delay_t>;
    /**
     * Maps coordinates of latch tiles to tuples containing their string representation, their clock zone,
     * and their latch offset.
     */
    //    using coord_to_latch_mapping = std::unordered_map<coord_t, svg_latch>;

    std::pair<std::string, std::string> generate_description_color(const typename Lyt::cell& c)
    {
        std::string cell_description, cell_color{};

        static constexpr const std::array<const char*, 4> cell_colors{
            {svg::clock_zone_1_cell, svg::clock_zone_2_cell, svg::clock_zone_3_cell, svg::clock_zone_4_cell}};

        if (lyt.is_empty_cell(c)) {}
        else if (const auto ct = lyt.get_cell_type(c); Lyt::technology::is_normal_cell(ct))
        {
            //            cell_color = lyt.get_latch(c) ? clock_zone_latch_cell : cell_colors[lyt.get_clock_number(c)];
            cell_color = cell_colors[lyt.get_clock_number(c)];
            if (ps.simple)
            {
                cell_description = svg::simple_cell;
            }
            else if (c.z != 0 && Lyt::technology::is_vertical_cell_mode(lyt.get_cell_mode(c)))
            {
                cell_description = svg::via;
            }
            else if ((c.z == 0 && !lyt.is_empty_cell(lyt.above(c))) || (c.z != 0 && lyt.is_empty_cell(lyt.below(c))))
            {
                cell_description = svg::cross;
            }
            else if (c.z != 0)
            {}
            else
            {
                cell_description = svg::cell;
            }
        }
        else if (Lyt::technology::is_input_cell(ct))
        {
            cell_color       = svg::pi_cell;
            cell_description = ps.simple ? svg::simple_cell : svg::cell;
        }
        else if (Lyt::technology::is_output_cell(ct))
        {
            cell_color       = svg::po_cell;
            cell_description = ps.simple ? svg::simple_cell : svg::cell;
        }
        else if (Lyt::technology::is_const_0_cell(ct))
        {
            cell_color       = "#000000";
            cell_description = ps.simple ? svg::simple_cell : svg::const0;
        }
        else if (Lyt::technology::is_const_1_cell(ct))
        {
            cell_color       = "#000000";
            cell_description = ps.simple ? svg::simple_cell : svg::const1;
        }
        else
        {
            throw unsupported_cell_type_exception(c);
        }

        return std::make_pair(cell_description, cell_color);
    }

    /**
     * Returns an SVG string representing the given cell-based clocked cell layout
     *
     * @param fcl The cell layout to generate an SVG representation for.
     * @param simple Flag to indicate that the SVG representation should be generated with less details. Recommended
     *               for large layouts.
     * @return The SVG string containing a visual representation of the given layout.
     */
    void generate_cell_based_svg()
    {
        std::stringstream cell_descriptions{};

        lyt.foreach_cell_position(
            [this, &cell_descriptions](const auto& c)
            {
                if (!lyt.is_empty_cell(c))
                {
                    // Determines cell type and color
                    const auto desc_col = generate_description_color(c);

                    // Current cell-description can now be appended to the description of all cells
                    //            if (lyt->get_latch(c))
                    //            {
                    //                cell_descriptions << fmt::format(
                    //                    desc_col.first, desc_col.second,
                    //                    svg::starting_offset_tile_x + svg::starting_offset_latch_cell_x + c.x *
                    //                    svg::cell_distance, svg::starting_offset_tile_y +
                    //                    svg::starting_offset_latch_cell_y + c.y * svg::cell_distance);
                    //            }
                    //            else
                    //            {
                    cell_descriptions << fmt::format(
                        desc_col.first, desc_col.second,
                        svg::starting_offset_tile_x + svg::starting_offset_cell_x + c.x * svg::cell_distance,
                        svg::starting_offset_tile_y + svg::starting_offset_cell_y + c.y * svg::cell_distance);
                    //            }
                }
            });

        const double viewbox_x = 2 * svg::viewbox_distance + static_cast<double>(lyt.x() + 1) * svg::cell_distance;
        const double viewbox_y = 2 * svg::viewbox_distance + static_cast<double>(lyt.y() + 1) * svg::cell_distance;

        os << fmt::format(svg::header, FICTION_VERSION, FICTION_REPO, viewbox_x, viewbox_y, cell_descriptions.str());
    }

    /**
     * Returns an SVG string representing the given tile-based clocked cell layout.
     *
     * @param fcl The cell layout to generate an SVG representation for.
     * @param simple Flag to indicate that the SVG representation should be generated with less details. Recommended
     *               for large layouts.
     * @return The SVG string containing a visual representation of the given layout.
     */
    void generate_tile_based_svg()
    {
        // Collects ALL tile-descriptions
        std::stringstream tile_descriptions{};

        // Used for generating tile-descriptions with information about the tile's coordinates and clock zone
        // It is needed because cells may not be in "tile-order" when read from a cell layout
        coord_to_tile_mapping      coord_to_tile{};
        coord_to_cell_list_mapping coord_to_cells{};
        //        coord_to_latch_mapping     coord_to_latch_tile{};
        coord_to_cell_list_mapping coord_to_latch_cells{};

        // Used to determine the color of cells, tiles and text based on its clock zone
        static constexpr const std::array<const char*, 4> tile_colors{
            {svg::clock_zone_1_tile, svg::clock_zone_2_tile, svg::clock_zone_3_tile, svg::clock_zone_4_tile}},
            text_colors{
                {svg::clock_zone_12_text, svg::clock_zone_12_text, svg::clock_zone_34_text, svg::clock_zone_34_text}};

        // Adds all non-empty cells from the layout to their correct tiles; it generates the "body"
        // of all the tile-descriptions to be used later
        lyt.foreach_cell_position(
            [this, &coord_to_tile, &coord_to_cells, &coord_to_latch_cells](const auto& c)
            {
                const auto clock_zone = lyt.get_clock_number(c);
                const auto tile_coords =
                    coord_t{std::ceil(c.x / lyt.get_tile_size_x()), std::ceil(c.y / lyt.get_tile_size_y())};
                //                const auto  latch_delay = fcl->get_latch(c);
                std::string current_cells;

                //                if (latch_delay)
                //                {
                //                    if (auto latch_it = coord_to_latch_cells.find(tile_coords); latch_it !=
                //                    coord_to_latch_cells.end())
                //                    {
                //                        current_cells = latch_it->second;
                //                    }
                //                    else
                //                    {
                //                        // If this is called, then there is no tile for the current cell yet
                //                        // It also makes sure that all required tiles are created
                //                        coord_to_latch_tile[tile_coords] = {latch, clock_zone, latch_delay};
                //                    }
                //                }
                //                else
                //                {
                if (auto cell_it = coord_to_cells.find(tile_coords); cell_it != coord_to_cells.end())
                {
                    current_cells = cell_it->second;
                }
                else
                {
                    // If this is called, then there is no tile for the current cell yet
                    // It also makes sure that all required tiles are created
                    coord_to_tile[tile_coords] = {svg::tile, clock_zone};
                }
                //                }

                // Represent the x- and y-coordinates inside the c's tile
                const coord_t in_tile{c.x % lyt.get_tile_size_x(), c.y % lyt.get_tile_size_y()};

                // Determines cell type and color
                const auto desc_col = generate_description_color(c);

                // Only add cell description if the cell is not empty
                if (!(lyt.is_empty_cell(c)))
                {
                    // Current cell-description can now be appended to the description of all cells in the current tile
                    //                    if (latch_delay)
                    //                    {
                    //                        coord_to_latch_cells[tile_coords] = current_cells.append(
                    //                            fmt::format(desc_col.first, desc_col.second,
                    //                                        svg::starting_offset_latch_cell_x + in_tile.x *
                    //                                        svg::cell_distance, svg::starting_offset_latch_cell_y +
                    //                                        in_tile.y * svg::cell_distance));
                    //                    }
                    //                    else
                    //                    {
                    coord_to_cells[tile_coords] = current_cells.append(fmt::format(
                        desc_col.first, desc_col.second, svg::starting_offset_cell_x + in_tile.x * svg::cell_distance,
                        svg::starting_offset_cell_y + in_tile.y * svg::cell_distance));
                    //                    }
                }
            });

        // All cell-descriptions are done and tiles have been created

        // Delete empty tiles in simple designs
        if (ps.simple)
        {
            std::vector<coord_t> empty_tiles{}, empty_latches{};

            // Find empty tiles via missing cell-descriptions for their coordinates
            for (const auto& [coord, tdscr] : coord_to_tile)
            {
                if (coord_to_cells.count(coord) > 0)
                {
                    empty_tiles.emplace_back(coord);
                }
            }

            // Find empty latches via missing cell-descriptions for their coordinates
            //            for (const auto& [coord, ldscr] : coord_to_latch_tile)
            //            {
            //                if (auto cell_it = coord_to_latch_cells.find(coord); cell_it ==
            //                coord_to_latch_cells.end())
            //                    empty_latches.emplace_back(coord);
            //            }

            // Delete empty tiles
            for (const auto& coord : empty_tiles) { coord_to_tile.erase(coord); }

            //            for (const auto& coord : empty_latches) coord_to_latch_tile.erase(coord);
        }

        // Associate tiles with cell-descriptions now; coordinates of tiles are used for tile- and cell-descriptions
        for (const auto& [coord, tdscr] : coord_to_tile)
        {
            const auto [descr, czone] = tdscr;

            const auto cell_descriptions = coord_to_cells[coord];

            const double x_pos = svg::starting_offset_tile_x + coord.x * svg::tile_distance;
            const double y_pos = svg::starting_offset_tile_y + coord.y * svg::tile_distance;

            const auto c_descr =
                fmt::format(descr, x_pos, y_pos, tile_colors[czone], cell_descriptions,
                            ps.simple ? "" : text_colors[czone], ps.simple ? "" : std::to_string(czone + 1));

            tile_descriptions << c_descr;
        }

        // Add the descriptions of latch-tiles to the whole image
        //        for (const auto& [coord, ldscr] : coord_to_latch_tile)
        //        {
        //            const auto [descr, czone_up, latch_delay] = ldscr;
        //            const auto czone_lo                       = czone_up + latch_delay % lyt.num_clocks();
        //
        //            const auto cell_descriptions = coord_to_latch_cells[coord];
        //
        //            const double x_pos = svg::starting_offset_latch_x + coord.x * svg::tile_distance;
        //            const double y_pos = svg::starting_offset_latch_y + coord.y * svg::tile_distance;
        //
        //            const auto t_descr =
        //                fmt::format(descr, x_pos, y_pos, tile_colors[czone_lo], tile_colors[czone_up],
        //                cell_descriptions,
        //                            text_colors[czone_up], ps.simple ? "" : std::to_string(czone_up + 1),
        //                            text_colors[czone_lo], ps.simple ? "" : std::to_string(czone_lo + 1));
        //
        //            tile_descriptions << t_descr;
        //        }

        const coord_t length = {(lyt.x() + 1) / lyt.get_tile_size_x(), (lyt.y() + 1) / lyt.get_tile_size_y()};

        const double viewbox_x = 2 * svg::viewbox_distance + length.x * svg::tile_distance;
        const double viewbox_y = 2 * svg::viewbox_distance + length.y * svg::tile_distance;

        os << fmt::format(svg::header, FICTION_VERSION, FICTION_REPO, viewbox_x, viewbox_y, tile_descriptions.str());
    }
};

}  // namespace detail

/**
 * Returns an SVG string representing the given cell layout. Both tile- and cell-based layouts are supported.
 *
 * For tile-based layouts, only QCA of tile size 5 x 5 is supported so far.
 *
 * May throw an 'unsupported_cell_type_exception'
 *
 * @param fcl The cell layout to generate an SVG representation for.
 * @param simple Flag to indicate that the SVG representation should be generated with less details. Recommended
 *               for large layouts.
 * @return The SVG string containing a visual representation of the given layout.
 */
template <typename Lyt>
void write_qca_layout_svg(const Lyt& lyt, std::ostream& os, write_qca_layout_svg_params ps = {})
{
    static_assert(std::is_same_v<typename Lyt::technology, qca_technology>, "Lyt has to be a QCA layout");

    detail::write_qca_layout_svg_impl<Lyt> p{lyt, os, ps};

    p.run();
}

}  // namespace fiction

#endif  // FICTION_WRITE_SVG_LAYOUT_HPP
